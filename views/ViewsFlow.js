// This file is automatically generated by Views and will be overwritten
// when the morpher runs. If you want to contribute to how it's generated, eg,
// improving the algorithms inside, etc, see this:
// https://github.com/viewstools/morph/blob/master/ensure-flow.js

import React, { useCallback, useContext, useEffect, useReducer } from 'react'

export let flowDefinition = new Map()

let TOP_VIEW = '/App'

function ensureFirstViewIsOn(key, flow) {
  if (!flow.has(key)) return

  let view = flowDefinition.get(key)
  if (view.views.size > 0) {
    let index = 0
    let canAdd = intersection(flow, view.views).size === 0
    for (let id of view.views) {
      if ((canAdd && index === 0) || !view.isSeparate) {
        flow.add(id)
      }
      index++
      ensureFirstViewIsOn(id, flow)
    }
  }
}

function ensureParents(key, flow) {
  let view = flowDefinition.get(key)
  if (!view) {
    console.error({ type: 'views/flow/missing-parent', id: key })
    return
  }
  if (!view.parent) {
    return
  }

  flow.add(view.parent)
  ensureParents(view.parent, flow)
}

function getAllChildrenOf(key, children) {
  if (!flowDefinition.has(key)) return

  let view = flowDefinition.get(key)
  for (let id of view.views) {
    children.add(id)
    getAllChildrenOf(id, children)
  }
}

let intersection = (a, b) => new Set([...a].filter((ai) => b.has(ai)))
let difference = (a, b) => new Set([...a].filter((ai) => !b.has(ai)))

function getNextFlow(key, flow) {
  if (flow.has(key)) return flow

  let next = new Set([key])

  ensureFirstViewIsOn(key, next)
  ensureParents(key, next)

  let diffIn = difference(next, flow)
  let diffOut = new Set()

  difference(flow, next).forEach((id) => {
    let view = flowDefinition.get(id)
    if (!view) {
      console.debug({ type: 'views/flow/missing-view', id })
      diffOut.add(id)
      return
    }

    if (flow.has(view.parent)) {
      let parent = flowDefinition.get(view.parent)
      if (intersection(parent.views, diffIn).size > 0) {
        diffOut.add(id)
        let children = new Set()
        getAllChildrenOf(id, children)
        children.forEach((cid) => diffOut.add(cid))
      }
    }
  })

  let nextFlow = new Set([...difference(flow, diffOut), ...diffIn])
  ensureFirstViewIsOn(TOP_VIEW, nextFlow)
  return new Set([...nextFlow].sort())
}

let MAX_ACTIONS = 10000
let SET = 'flow/SET'

let Context = React.createContext([{ actions: [], flow: new Set() }, () => {}])
export let useFlowState = () => useContext(Context)[0]
export let useFlow = () => useFlowState().flow
export let useSetFlowTo = () => {
  let [, dispatch] = useContext(Context)
  return useCallback((id) => dispatch({ type: SET, id }), []) // eslint-disable-line
  // ignore dispatch
}

function getNextActions(state, id) {
  return [id, ...state.actions].slice(0, MAX_ACTIONS)
}

function reducer(state, action) {
  switch (action.type) {
    case SET: {
      if (process.env.NODE_ENV === 'development') {
        console.debug({ type: 'views/flow/set', id: action.id })

        if (!flowDefinition.has(action.id)) {
          console.error({
            type: 'views/flow/invalid-view',
            id: action.id,
            flowDefinition,
          })
          return state
        }
      }

      if (state.actions[0] === action.id) {
        if (process.env.NODE_ENV === 'development') {
          console.debug({
            type: 'views/flow/already-set-as-last-action-ignoring',
            id: action.id,
            actions: state.actions,
          })
        }
        return state
      }

      return {
        flow: getNextFlow(action.id, state.flow),
        actions: getNextActions(state, action.id),
      }
    }

    default: {
      throw new Error(`Unknown action "${action.type}" in Flow`)
    }
  }
}

export function ViewsFlow(props) {
  let context = useReducer(reducer, { actions: [], flow: props.initialState })
  let [state] = context

  useEffect(() => {
    if (typeof props.onChange === 'function') {
      props.onChange(state)
    }
  }, [state]) // eslint-disable-line
  // ignore props.onChange

  return <Context.Provider value={context}>{props.children}</Context.Provider>
}

ViewsFlow.defaultProps = {
  initialState: new Set(),
}

export function normalizePath(viewPath, relativePath) {
  let url = new URL(`file://${viewPath}/${relativePath}`)
  return url.pathname
}
