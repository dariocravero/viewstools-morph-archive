// This file is automatically generated by Views and will be overwritten
// when the morpher runs. If you want to contribute to how it's generated, eg,
// improving the algorithms inside, etc, see this:
// https://github.com/viewstools/morph/blob/master/ensure-data.js
import * as fromValidate from './validate.js'
import * as fromFormat from './format.js'
// import get from 'dlv';
import get from 'lodash/get'
import produce from 'immer'
// import set from 'dset';
import set from 'lodash/set'
import React, {
  useContext,
  useEffect,
  useMemo,
  useReducer,
  useRef,
} from 'react'

let SET = 'data/SET'
let SET_FN = 'data/SET_FN'
let RESET = 'data/RESET'
let FORCE_REQUIRED = 'data/FORCE_REQUIRED'
let IS_SUBMITTING = 'data/IS_SUBMITTING'
let reducer = produce((draft, action) => {
  switch (action.type) {
    case SET: {
      set(draft, action.path, action.value)
      break
    }

    case SET_FN: {
      action.fn(draft, set, get)
      break
    }

    case RESET: {
      return action.value
    }

    case IS_SUBMITTING: {
      draft._isSubmitting = action.value
      break
    }

    case FORCE_REQUIRED: {
      draft._forceRequired = true
      draft._isSubmitting = false
      break
    }

    default: {
      throw new Error(
        `Unknown action type "${action.type}" in useData reducer.`
      )
    }
  }
})

let DataContexts = {
  default: React.createContext([]),
}
export function DataProvider(props) {
  if (!props.context) {
    throw new Error(
      `You're missing the context value in DataProvider. Eg: <DataProvider context="namespace" ...`
    )
  }
  if (!(props.context in DataContexts)) {
    DataContexts[props.context] = React.createContext([])
    DataContexts[props.context].displayName = props.context
  }
  let Context = DataContexts[props.context]
  let _value = props.value

  if (process.env.NODE_ENV === 'development') {
    if (props.viewPath) {
      let key = `${props.context}:${props.viewPath}`
      let cache = sessionStorage.getItem(`ViewsDataContextValues:${key}`)
      _value = cache ? JSON.parse(cache) : _value
    }
  }

  let [state, dispatch] = useReducer(reducer, _value)
  let isSubmitting = useRef(false)
  let shouldCallOnChange = useRef(false)

  useEffect(() => {
    if (isSubmitting.current) return

    shouldCallOnChange.current = false

    let _value = props.value
    if (process.env.NODE_ENV === 'development') {
      if (props.viewPath) {
        let key = `${props.context}:${props.viewPath}`
        let cache = sessionStorage.getItem(`ViewsDataContextValues:${key}`)
        _value = cache ? JSON.parse(cache) : _value
      }
    }

    dispatch({ type: RESET, value: _value })
  }, [props.value]) // eslint-disable-line
  // ignore dispatch

  let value = useMemo(() => {
    async function onSubmit(args) {
      if (isSubmitting.current) return
      isSubmitting.current = true

      try {
        dispatch({ type: IS_SUBMITTING, value: true })
        let res = await props.onSubmit(state, args)
        isSubmitting.current = false

        if (!res) {
          dispatch({ type: IS_SUBMITTING, value: false })
          return
        }
      } catch (error) {
        isSubmitting.current = false
      }

      dispatch({ type: FORCE_REQUIRED })
    }

    return [state, dispatch, onSubmit]
  }, [state, props.onSubmit]) // eslint-disable-line
  // the linter says we need props when props.onSubmit is already there

  // keep track of props.onChange outside of the following effect to
  // prevent loops. Making the function useCallback didn't work
  let onChange = useRef(props.onChange)
  useEffect(() => {
    onChange.current = props.onChange
  }, [props.onChange])

  useEffect(() => {
    if (!shouldCallOnChange.current) {
      shouldCallOnChange.current = true
      return
    }

    if (process.env.NODE_ENV === 'development') {
      if (props.viewPath) {
        let key = `${props.context}:${props.viewPath}`
        sessionStorage.setItem(
          `ViewsDataContextValues:${key}`,
          JSON.stringify(state)
        )
      }
    }

    onChange.current(state, (fn) => dispatch({ type: SET_FN, fn }))
  }, [state]) // eslint-disable-line
  // ignore props.context, props.viewPath

  return <Context.Provider value={value}>{props.children}</Context.Provider>
}
DataProvider.defaultProps = {
  context: 'default',
  onChange: () => {},
  onSubmit: () => {},
}

export function useData({
  path = null,
  context = 'default',
  formatIn = null,
  formatOut = null,
  validate = null,
  validateRequired = false,
} = {}) {
  if (process.env.NODE_ENV === 'development') {
    if (!(context in DataContexts)) {
      throw new Error(
        `"${context}" isn't a valid Data context. Check that you have <DataProvider context="${context}" value={data}> in the component that defines the context for this story.`
      )
    }

    if (formatIn && !(formatIn in fromFormat)) {
      throw new Error(
        `"${formatIn}" function doesn't exist or is not exported in Data/format.js`
      )
    }

    if (formatOut && !(formatOut in fromFormat)) {
      throw new Error(
        `"${formatOut}" function doesn't exist or is not exported in Data/format.js`
      )
    }

    if (validate && !(validate in fromValidate)) {
      throw new Error(
        `"${validate}" function doesn't exist or is not exported in Data/validators.js`
      )
    }
  }

  let contextValue = useContext(DataContexts[context])
  let touched = useRef(false)

  return useMemo(() => {
    let [data, dispatch, onSubmit] = contextValue

    if (!data) {
      if (process.env.NODE_ENV === 'development') {
        console.error(
          'Check that you have <DataProvider value={data}> in the component that defines the data for this story.',
          {
            path,
            formatIn,
            formatOut,
            validate,
            validateRequired,
            data,
          }
        )
      }
      return {}
    }

    let rawValue = path ? get(data, path) : data
    let value = rawValue
    if (path && formatIn) {
      value = fromFormat[formatIn](rawValue, data)
    }

    let isValidInitial = true
    if (validate) {
      isValidInitial = fromValidate[validate](rawValue, value, data)
    }
    let isValid =
      touched.current || (validateRequired && data._forceRequired)
        ? isValidInitial
        : true

    function onChange(value, changePath = path) {
      touched.current = !!value

      if (typeof value === 'function') {
        dispatch({ type: SET_FN, fn: value })
      } else if (!changePath) {
        dispatch({ type: RESET, value })
      } else {
        dispatch({
          type: SET,
          path: changePath,
          value: formatOut ? fromFormat[formatOut](value, data) : value,
        })
      }
    }

    return {
      onChange,
      onSubmit,
      value,
      isSubmitting: data._isSubmitting,
      isValid,
      isValidInitial,
      isInvalid: !isValid,
      isInvalidInitial: !isValidInitial,
    }
  }, [contextValue, path, formatIn, formatOut, validateRequired, validate])
}
