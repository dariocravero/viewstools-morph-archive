// This file is automatically generated by Views and will be overwritten
// when the morpher runs. If you want to contribute to how it's generated, eg,
// improving the algorithms inside, etc, see this:
// https://github.com/viewstools/morph/blob/master/ensure-flow.js

import React, { useCallback, useContext, useEffect, useReducer } from 'react'
import ViewsTools from './ViewsTools.js'

export let flow = new Map()

let TOP_VIEW = '/App'

function ensureFirstViewIsOn(key, views) {
  if (!views.has(key)) return

  let view = flow.get(key)
  if (view.views.size > 0) {
    let index = 0
    let canAdd = intersection(views, view.views).size === 0
    for (let id of view.views) {
      if ((canAdd && index === 0) || !view.isSeparate) {
        views.add(id)
      }
      index++
      ensureFirstViewIsOn(id, views)
    }
  }
}

function ensureParents(key, views) {
  let view = flow.get(key)
  if (!view) {
    console.error({ type: 'views/flow/missing-parent', id: key })
    return
  }
  if (!view.parent) {
    return
  }

  views.add(view.parent)
  ensureParents(view.parent, views)
}

function getAllChildrenOf(key, children) {
  if (!flow.has(key)) return

  let view = flow.get(key)
  for (let id of view.views) {
    children.add(id)
    getAllChildrenOf(id, children)
  }
}

let intersection = (a, b) => new Set([...a].filter((ai) => b.has(ai)))
let difference = (a, b) => new Set([...a].filter((ai) => !b.has(ai)))

function getNextFlow(key, state) {
  if (state.has(key)) return state

  let next = new Set([key])

  ensureFirstViewIsOn(key, next)
  ensureParents(key, next)

  let diffIn = difference(next, state)
  let diffOut = new Set()

  difference(state, next).forEach((id) => {
    let view = flow.get(id)
    if (!view) {
      console.debug({ type: 'views/flow/missing-view', id })
      diffOut.add(id)
      return
    }

    if (state.has(view.parent)) {
      let parent = flow.get(view.parent)
      if (intersection(parent.views, diffIn).size > 0) {
        diffOut.add(id)
        let children = new Set()
        getAllChildrenOf(id, children)
        children.forEach((cid) => diffOut.add(cid))
      }
    }
  })

  let nextState = new Set([...difference(state, diffOut), ...diffIn])
  ensureFirstViewIsOn(TOP_VIEW, nextState)
  return new Set([...nextState].sort())
}

let MAX_ACTIONS = 10000
let SYNC = 'flow/SYNC'
let SET = 'flow/SET'

let Context = React.createContext([{ actions: [], flow: new Set() }, () => {}])
export let useFlowState = () => useContext(Context)[0]
export let useFlow = () => useFlowState().flow
export let useSetFlowTo = () => {
  let [, dispatch] = useContext(Context)
  return useCallback((id) => dispatch({ type: SET, id }), []) // eslint-disable-line
  // ignore dispatch
}

function getNextActions(state, id) {
  return [id, ...state.actions].slice(0, MAX_ACTIONS)
}

function reducer(state, action) {
  switch (action.type) {
    case SYNC: {
      console.debug({ type: 'views/flow/sync', id: action.id })

      return {
        flow: new Set(action.flow),
        actions: getNextActions(state, action.id),
      }
    }

    case SET: {
      if (process.env.NODE_ENV === 'development') {
        console.debug({ type: 'views/flow/set', id: action.id })

        if (!flow.has(action.id)) {
          console.error({
            type: 'views/flow/invalid-view',
            id: action.id,
            availableViews: flow,
          })
          return state
        }

        if (ViewsTools.SYNC_ONE_WAY) {
          return action.id.startsWith(ViewsTools.SYNC_ONE_WAY)
            ? {
                flow: getNextFlow(action.id, state.flow),
                actions: state.actions,
              }
            : state
        }
      }

      if (state.actions[0] === action.id) {
        if (process.env.NODE_ENV === 'development') {
          console.debug({
            type: 'views/flow/already-set-as-last-action-ignoring',
            id: action.id,
            actions: state.actions,
          })
        }
        return state
      }

      return {
        flow: getNextFlow(action.id, state.flow),
        actions: getNextActions(state, action.id),
      }
    }

    default: {
      throw new Error(`Unknown action "${action.type}" in Flow`)
    }
  }
}

export function ViewsFlow(props) {
  let context = useReducer(reducer, { actions: [], flow: props.initialState })
  let [state] = context

  useEffect(() => {
    if (typeof props.onChange === 'function') {
      props.onChange(state)
    }
  }, [state]) // eslint-disable-line
  // ignore props.onChange

  return (
    <Context.Provider value={context}>
      <ViewsTools
        flow={context}
        onFlowMapChange={(next) => {
          flow = new Map(
            JSON.parse(next).map(([key, value]) => [
              key,
              { ...value, views: new Set(value.views) },
            ])
          )
        }}
      >
        {props.children}
      </ViewsTools>
    </Context.Provider>
  )
}

ViewsFlow.defaultProps = {
  initialState: new Set([TOP_VIEW]),
}

export function normalizePath(viewPath, relativePath) {
  let url = new URL(`file://${viewPath}/${relativePath}`)
  return url.pathname
}
