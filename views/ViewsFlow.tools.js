// This file is automatically generated by Views and will be overwritten
// when the morpher runs. If you want to contribute to how it's generated, eg,
// improving the algorithms inside, etc, see this:
// https://github.com/viewstools/morph/blob/master/ensure-flow.js

import React, { useCallback, useContext, useEffect, useReducer } from 'react'
import ViewsTools from './ViewsTools.js'

export let flowDefinition = new Map()
function getFlowDefinitionKey(key) {
  return key.replace(/\(.+?\)/g, '')
}
function getFlowKeyWithoutEndingArguments(key) {
  // TODO ideally we'd do this with a regex and replace
  if (!key.endsWith(')')) return key
  let bits = key.split('/')
  bits[bits.length - 1] = bits[bits.length - 1].replace(/\(.+\)$/, '')
  return bits.join('/')
}
function getFlowDefinition(key) {
  return flowDefinition.get(getFlowDefinitionKey(key))
}
function getViewsRelativeToDefinition(key, views) {
  return new Set([...views].map((id) => `${key}/${id}`))
}

let TOP_VIEW = '/App'

function ensureFirstViewIsOn(key, flow) {
  if (!flow.has(key)) return

  let view = getFlowDefinition(key)
  if (view.views.size === 0) return

  let index = 0
  let views = getViewsRelativeToDefinition(key, view.views)
  let canAdd = intersection(flow, views).size === 0
  for (let id of views) {
    if ((canAdd && index === 0) || !view.isSeparate) {
      flow.add(id)
    }
    index++
    ensureFirstViewIsOn(id, flow)
  }
}

function ensureParents(key, flow) {
  let view = getFlowDefinition(key)
  if (!view) {
    console.error({ type: 'views/flow/missing-parent', id: key })
    return
  }
  if (!view.parent) return

  flow.add(view.parent)
  ensureParents(view.parent, flow)
}

function getAllChildrenOf(key, children) {
  if (!flowDefinition.has(key)) return

  let view = getFlowDefinition(key)
  let views = getViewsRelativeToDefinition(key, view.views)
  for (let id of views) {
    children.add(id)
    getAllChildrenOf(id, children)
  }
}

function getNextFlow(key, flow) {
  if (flow.has(key)) return flow

  let next = new Set([key])

  ensureFirstViewIsOn(key, next)
  ensureParents(key, next)

  let diffIn = difference(next, flow)
  let diffOut = new Set()

  difference(flow, next).forEach((id) => {
    let view = getFlowDefinition(id)
    if (!view) {
      console.debug({ type: 'views/flow/missing-view', id })
      diffOut.add(id)
      return
    }

    if (flow.has(view.parent)) {
      let parent = getFlowDefinition(view.parent)
      // remove last bit of () from key if present and ending with it
      let parentViews = getViewsRelativeToDefinition(
        getFlowKeyWithoutEndingArguments(key),
        parent.views
      )
      // TODO if view has ending arguments, ensure views without the argument
      // aren't in the flow, eg /App/Todos/Todo(1) shouldn't have
      // /App/Todos/Todo
      if (intersection(parentViews, diffIn).size > 0) {
        diffOut.add(id)
        let children = new Set()
        getAllChildrenOf(id, children)
        children.forEach((cid) => diffOut.add(cid))
      }
    }
  })

  let nextFlow = new Set([...difference(flow, diffOut), ...diffIn])
  ensureFirstViewIsOn(TOP_VIEW, nextFlow)
  return new Set([...nextFlow].sort())
}

let MAX_ACTIONS = 10000
let SYNC = 'flow/SYNC'
let SET = 'flow/SET'

let Context = React.createContext([{ actions: [], flow: new Set() }, () => {}])
export let useFlowState = () => useContext(Context)[0]
export let useFlow = () => useFlowState().flow
export let useSetFlowTo = () => {
  let [, dispatch] = useContext(Context)
  return useCallback((id) => dispatch({ type: SET, id }), []) // eslint-disable-line
  // ignore dispatch
}

function getNextActions(state, id) {
  return [id, ...state.actions].slice(0, MAX_ACTIONS)
}

function reducer(state, action) {
  switch (action.type) {
    case SYNC: {
      console.debug({ type: 'views/flow/sync', id: action.id })

      return {
        flow: new Set(action.flow),
        actions: getNextActions(state, action.id),
      }
    }

    case SET: {
      if (process.env.NODE_ENV === 'development') {
        console.debug({ type: 'views/flow/set', id: action.id })

        let definitionKey = getFlowDefinitionKey(action.id)
        if (!flowDefinition.has(definitionKey)) {
          console.error({
            type: 'views/flow/invalid-view',
            id: action.id,
            definitionKey,
            flowDefinition,
          })
          return state
        }

        if (ViewsTools.SYNC_ONE_WAY) {
          return action.id.startsWith(ViewsTools.SYNC_ONE_WAY)
            ? {
                flow: getNextFlow(action.id, state.flow),
                actions: state.actions,
              }
            : state
        }
      }

      if (state.actions[0] === action.id) {
        if (process.env.NODE_ENV === 'development') {
          console.debug({
            type: 'views/flow/already-set-as-last-action-ignoring',
            id: action.id,
            actions: state.actions,
          })
        }
        return state
      }

      return {
        flow: getNextFlow(action.id, state.flow),
        actions: getNextActions(state, action.id),
      }
    }

    default: {
      throw new Error(`Unknown action "${action.type}" in Flow`)
    }
  }
}

export function ViewsFlow(props) {
  let context = useReducer(reducer, { actions: [], flow: props.initialState })
  let [state] = context

  useEffect(() => {
    if (typeof props.onChange === 'function') {
      props.onChange(state)
    }
  }, [state]) // eslint-disable-line
  // ignore props.onChange

  return (
    <Context.Provider value={context}>
      <ViewsTools
        flow={context}
        onFlowMapChange={(next) => {
          flowDefinition.clear()
          JSON.parse(next).forEach(([key, value]) => {
            flowDefinition.set(key, { ...value, views: new Set(value.views) })
          })
        }}
      >
        {props.children}
      </ViewsTools>
    </Context.Provider>
  )
}

ViewsFlow.defaultProps = {
  initialState: new Set([TOP_VIEW]),
}

export function normalizePath(viewPath, relativePath) {
  let url = new URL(`file://${viewPath}/${relativePath}`)
  return url.pathname
}

function intersection(a, b) {
  return new Set([...a].filter((ai) => b.has(ai)))
}
function difference(a, b) {
  return new Set([...a].filter((ai) => !b.has(ai)))
}
