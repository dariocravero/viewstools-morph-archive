import ensureFile from './ensure-file.js'
import getViewRelativeToView from './get-view-relative-to-view.js'
import path from 'path'

function ensureFirstStoryIsOn(flow, key, stories) {
  if (!stories.has(key)) return

  let story = flow.get(key)
  if (story && story.stories.size > 0) {
    let index = 0
    for (let id of story.stories) {
      if (index === 0 || !story.isSeparate) {
        stories.add(id)
      }
      index++
      ensureFirstStoryIsOn(flow, id, stories)
    }
  }
}

function makeFlow({ tools, viewsById, viewsToFiles }) {
  let flowMap = new Map()
  let flowMapStr = []

  for (let view of viewsToFiles.values()) {
    if (!view || view.custom || !view.parsed.view.isStory) continue

    let states = []
    for (let id of view.parsed.view.views) {
      let viewInView = getViewRelativeToView({
        id,
        view,
        viewsById,
        viewsToFiles,
      })

      if (viewInView && !viewInView.custom && viewInView.parsed.view.isStory) {
        states.push(viewInView.parsed.view.viewPath) // `${pathToViewId}/${id}`)
      }
    }

    let isSeparate = view.parsed.view.flow === 'separate'
    let parent = view.parsed.view.viewPathParent

    flowMapStr.push(
      `['${view.parsed.view.viewPath}', { isSeparate: ${isSeparate}, parent: '${
        parent === '/' ? '' : parent
      }',
  stories: new Set(${states.length > 0 ? JSON.stringify(states) : ''}) }]`
    )
    flowMap.set(view.parsed.view.viewPath, {
      parent,
      isSeparate,
      stories: new Set(states),
    })
  }

  let topStory = '/App'
  let initialState = new Set([topStory])
  ensureFirstStoryIsOn(flowMap, topStory, initialState)

  return `// This file is automatically generated by Views and will be overwritten
// when the morpher runs. If you want to contribute to how it's generated, eg,
// improving the algorithms inside, etc, see this:
// https://github.com/viewstools/morph/blob/master/ensure-flow.js

import React, { useCallback, useContext, useEffect, useReducer } from 'react'
${tools ? "import ViewsTools from './ViewsTools.js'" : ''}

export let flow = new Map([
${flowMapStr.join(',\n')}
])

let TOP_STORY = "${topStory}"

function ensureFirstStoryIsOn(key, stories) {
  if (!stories.has(key)) return

  let story = flow.get(key)
  if (story.stories.size > 0) {
    let index = 0
    let canAdd = intersection(stories, story.stories).size === 0
    for (let id of story.stories) {
      if ((canAdd && index === 0) || !story.isSeparate) {
        stories.add(id)
      }
      index++
      ensureFirstStoryIsOn(id, stories)
    }
  }
}

function ensureParents(key, stories) {
  let story = flow.get(key)
  if (!story) {
    console.error(\`View "\${key}" is missing its parent\`)
    return
  }
  if (!story.parent) {
    return
  }

  stories.add(story.parent)
  ensureParents(story.parent, stories)
}

function getAllChildrenOf(key, children) {
  if (!flow.has(key)) return

  let story = flow.get(key)
  for (let id of story.stories) {
    children.add(id)
    getAllChildrenOf(id, children)
  }
}


let intersection = (a, b) => new Set([...a].filter(ai => b.has(ai)))
let difference = (a, b) => new Set([...a].filter(ai => !b.has(ai)))

function getNextFlow(key, state) {
  if (state.has(key)) return state

  let next = new Set([key])

  ensureFirstStoryIsOn(key, next)
  ensureParents(key, next)

  let diffIn = difference(next, state)
  let diffOut = new Set()

  difference(state, next).forEach(id => {
    let story = flow.get(id)
    if (!story) {
      console.debug({ type: 'views/flow/missing-story', id })
      diffOut.add(id)
      return
    }

    if (state.has(story.parent)) {
      let parent = flow.get(story.parent)
      if (intersection(parent.stories, diffIn).size > 0) {
        diffOut.add(id)
        let children = new Set()
        getAllChildrenOf(id, children)
        children.forEach(cid => diffOut.add(cid))
      }
    }
  })

  let nextState = new Set([...difference(state, diffOut), ...diffIn])
  ensureFirstStoryIsOn(TOP_STORY, nextState)
  return new Set([...nextState].sort())
}

let MAX_ACTIONS = 10000
let SYNC = 'flow/SYNC'
let SET = 'flow/SET'

let Context = React.createContext([{ actions: [], flow: new Set() }, () => {}])
export let useFlowState = () => useContext(Context)[0]
export let useFlow = () => useFlowState().flow
export let useSetFlowTo = () => {
  let [, dispatch] = useContext(Context)
  return useCallback(id => dispatch({ type: SET, id }), []) // eslint-disable-line
  // ignore dispatch
}

function getNextActions(state, id) {
  return [id, ...state.actions].slice(0, MAX_ACTIONS)
}

function reducer(state, action) {
  switch (action.type) {
    ${
      tools
        ? `case SYNC: {
      return {
        flow: new Set(action.flow),
        actions: getNextActions(state, action.id)
      }
    }`
        : ''
    }

    case SET: {
      if (process.env.NODE_ENV === 'development') {
        console.debug({ type: 'views/flow/set', id: action.id })

        if (!flow.has(action.id)) {
          console.debug({ type: 'views/flow/invalid-story', id: action.id, availableStories: flow })
          throw new Error(
            \`Story "$\{action.id}" doesn't exist. See the valid stories logged above this error.\`
          )
        }

        if (ViewsTools.SYNC_ONE_WAY) {
          return action.id.startsWith(ViewsTools.SYNC_ONE_WAY)
            ? {
                flow: getNextFlow(action.id, state.flow),
                actions: state.actions,
              }
            : state;
        }
      }

      if (state.actions[0] === action.id) {
        if (process.env.NODE_ENV === 'development') {
          console.debug({ type: 'views/flow/already-set-as-last-action-ignoring', id: action.id, actions: state.actions })
        }
        return state
      }

      return {
        flow: getNextFlow(action.id, state.flow),
        actions: getNextActions(state, action.id)
      }
    }

    default: {
      throw new Error(\`Unknown action "\${action.type}" in Flow\`)
    }
  }
}

export function ViewsFlow(props) {
  let context = useReducer(reducer, { actions: [], flow: props.initialState })
  let [state] = context

  useEffect(() => {
    if (typeof props.onChange === 'function') {
      props.onChange(state)
    }
  }, [state]) // eslint-disable-line
  // ignore props.onChange

  return (
    <Context.Provider value={context}>
      ${
        tools
          ? '<ViewsTools flow={context}>{props.children}</ViewsTools>'
          : '{props.children}'
      }
    </Context.Provider>
  )
}

ViewsFlow.defaultProps = {
  initialState: new Set(${JSON.stringify([...initialState], null, '  ')})
}

export function normalizePath(viewPath, relativePath) {
  let url = new URL(\`file://\${viewPath}/\${relativePath}\`)
  return url.pathname
}`
}

export default function ensureFlow({ src, tools, viewsById, viewsToFiles }) {
  return ensureFile({
    file: path.join(src, 'Logic', 'ViewsFlow.js'),
    content: makeFlow({ tools, viewsById, viewsToFiles }),
  })
}
